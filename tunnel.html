<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ORBIT: Tunnel Run</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body { margin: 0; overflow: hidden; background: #000; color: #fff; font-family: 'Orbitron', sans-serif; }

        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        .hud-top {
            position: absolute; top: 20px; width: 100%; text-align: center;
            display: flex; justify-content: space-between; padding: 0 20px;
        }
        .score { font-size: 2rem; color: #0ff; text-shadow: 0 0 10px #0ff; }
        .role-display { font-size: 1rem; color: #fff; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; border: 1px solid #333; }

        .controls-layer {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 50%;
            display: flex; pointer-events: auto;
        }

        .steer-zone {
            flex: 1; border-top: 2px solid rgba(0, 255, 255, 0.3);
            background: linear-gradient(to top, rgba(0, 255, 255, 0.1), transparent);
            display: flex; align-items: center; justify-content: center;
            font-size: 3rem; color: rgba(0, 255, 255, 0.5);
            transition: background 0.1s;
        }
        .steer-zone:active { background: rgba(0, 255, 255, 0.3); color: #fff; }
        .steer-left { border-right: 1px solid rgba(0, 255, 255, 0.3); }

        .boost-zone {
            width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(255, 0, 85, 0.2) 0%, transparent 70%);
            display: flex; align-items: center; justify-content: center;
            border-top: 2px solid rgba(255, 0, 85, 0.5);
        }
        .boost-btn {
            width: 150px; height: 150px; border-radius: 50%;
            background: rgba(255, 0, 85, 0.2); border: 4px solid #ff0055;
            color: #ff0055; font-size: 1.5rem; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.5);
            transition: transform 0.1s, background 0.1s;
        }
        .boost-btn:active { transform: scale(0.95); background: rgba(255, 0, 85, 0.6); color: #fff; }

        #btn-swap {
            position: absolute; top: 80px; right: 20px; pointer-events: auto;
            background: #333; color: #fff; border: 1px solid #555;
            padding: 8px 12px; font-family: 'Orbitron'; cursor: pointer;
            z-index: 100; font-size: 0.8rem;
        }

        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 20; pointer-events: auto;
        }
        .hidden { display: none !important; }
        h1 { color: #ff0055; margin-bottom: 10px; font-size: 3rem; }
        p { color: #aaa; }
        button.retry-btn {
            margin-top: 20px; padding: 15px 40px; font-size: 1.2rem;
            background: #ff0055; border: none; color: #fff; font-family: 'Orbitron';
            cursor: pointer; box-shadow: 0 0 20px rgba(255, 0, 85, 0.5);
        }

        #waiting-msg { font-size: 1.2rem; color: #0ff; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 0.5; } 100% { opacity: 1; } }

    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="game-ui">
        <div class="hud-top">
            <div class="role-display" id="my-role-text">ROLE: ???</div>
            <div class="score">DIST: <span id="score-val">0</span></div>
        </div>

        <button id="btn-swap">SWAP ROLES</button>

        <div id="controls-driver" class="controls-layer hidden">
            <div class="steer-zone steer-left" id="btn-left">◀ LEFT</div>
            <div class="steer-zone steer-right" id="btn-right">RIGHT ▶</div>
        </div>

        <div id="controls-speeder" class="controls-layer hidden">
            <div class="boost-zone">
                <div class="boost-btn" id="btn-boost">HOLD<br>BOOST</div>
            </div>
        </div>

        <div id="loading-screen" class="screen">
            <div id="waiting-msg">CONNECTING...</div>
        </div>

        <div id="game-over-screen" class="screen hidden">
            <h1>CRASHED</h1>
            <p>Distance: <span id="final-score">0</span></p>
            <button class="retry-btn" id="btn-retry">RETRY</button>
        </div>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const ROOM_ID = urlParams.get('room');
        const MY_ROLE = urlParams.get('role');

        if (!ROOM_ID || !MY_ROLE) {
            window.location.href = 'index.html';
        }

        // State
        const state = {
            playing: false,
            score: 0,
            speed: 0,
            x: 0,
            driver: 'host',
            speeder: 'client',
            inputSteer: 0,
            inputBoost: false,
            obstacles: []
        };

        // Network
        let peer, conn;
        const PEER_ID = `${ROOM_ID}-tunnel`;

        function initNetwork() {
            if (MY_ROLE === 'host') {
                peer = new Peer(PEER_ID);
                peer.on('open', (id) => {
                    console.log("Host Ready:", id);
                    document.getElementById('waiting-msg').innerText = "WAITING FOR P2...";
                });
                peer.on('connection', (c) => handleConnection(c));
                peer.on('error', (err) => {
                    if (err.type === 'unavailable-id') {
                        // Host ID conflict - maybe user reloaded page?
                        // Let's try appending a random suffix? No, client won't know it.
                        // Assume session is dead, redirect to lobby.
                        alert("Session invalid. Please create new room.");
                        window.location.href = 'index.html';
                    }
                });
            } else {
                peer = new Peer();
                peer.on('open', () => {
                    conn = peer.connect(PEER_ID);
                    handleConnection(conn);
                });
                peer.on('error', (err) => {
                     console.error(err);
                     alert("Connection Failed: " + err.type);
                });
            }
        }

        function handleConnection(connection) {
            conn = connection;
            conn.on('open', () => {
                document.getElementById('loading-screen').classList.add('hidden');
                updateRoleUI();
                if (MY_ROLE === 'host') startGame();
            });
            conn.on('data', (data) => {
                if (data.type === 'STATE' && MY_ROLE === 'client') {
                    state.x = data.x;
                    state.speed = data.speed;
                    state.score = data.score;
                    state.obstacles = data.obstacles; // Full sync
                    state.driver = data.driver;
                    state.speeder = data.speeder;
                    state.playing = data.playing;
                    updateRoleUI();
                    if (!state.playing) endGame(state.score); // Sync game over
                } else if (data.type === 'INPUT' && MY_ROLE === 'host') {
                    if (state.driver === 'client') state.inputSteer = data.steer;
                    if (state.speeder === 'client') state.inputBoost = data.boost;
                } else if (data.type === 'SWAP' && MY_ROLE === 'host') {
                     const temp = state.driver;
                     state.driver = state.speeder;
                     state.speeder = temp;
                     updateRoleUI();
                } else if (data.type === 'GAME_OVER') {
                    endGame(data.score);
                } else if (data.type === 'RESTART') {
                    resetGame();
                }
            });
            conn.on('close', () => {
                alert("Partner Disconnected");
                window.location.href = 'index.html';
            });
        }

        function updateRoleUI() {
            const amIDriver = (MY_ROLE === state.driver);
            document.getElementById('my-role-text').innerText = amIDriver ? "ROLE: DRIVER (STEER)" : "ROLE: NAVIGATOR (BOOST)";
            if (amIDriver) {
                document.getElementById('controls-driver').classList.remove('hidden');
                document.getElementById('controls-speeder').classList.add('hidden');
            } else {
                document.getElementById('controls-driver').classList.add('hidden');
                document.getElementById('controls-speeder').classList.remove('hidden');
            }
        }

        // Three.js
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 6);
        camera.lookAt(0, 0, -10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('game-container').appendChild(renderer.domElement);

        const light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(0, 10, 0);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // Tunnel Visuals
        const tunnelGeo = new THREE.CylinderGeometry(15, 15, 200, 32, 1, true);
        const tunnelMat = new THREE.MeshBasicMaterial({ color: 0x220033, side: THREE.BackSide, wireframe: true });
        const tunnel = new THREE.Mesh(tunnelGeo, tunnelMat);
        tunnel.rotation.x = -Math.PI / 2;
        scene.add(tunnel);

        // Player
        const playerGeo = new THREE.ConeGeometry(0.8, 2, 16);
        playerGeo.rotateX(Math.PI / 2);
        const playerMat = new THREE.MeshNormalMaterial();
        const player = new THREE.Mesh(playerGeo, playerMat);
        scene.add(player);

        // Obstacles
        const obstacleGroup = new THREE.Group();
        scene.add(obstacleGroup);
        const meshMap = new Map();

        function createObstacle(z, x, id) {
             const geo = new THREE.BoxGeometry(3, 3, 3);
             const mat = new THREE.MeshBasicMaterial({ color: 0xff0055, wireframe: true });
             const mesh = new THREE.Mesh(geo, mat);
             mesh.position.set(x, 0, z);
             mesh.userData = { id: id };
             return mesh;
        }

        // Input
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnBoost = document.getElementById('btn-boost');

        function handleSteer(val) {
            if (MY_ROLE === state.driver) {
                state.inputSteer = val;
                if (MY_ROLE === 'client') sendInput();
            }
        }
        function handleBoost(val) {
            if (MY_ROLE === state.speeder) {
                state.inputBoost = val;
                if (MY_ROLE === 'client') sendInput();
            }
        }

        btnLeft.addEventListener('pointerdown', () => handleSteer(-1));
        btnLeft.addEventListener('pointerup', () => handleSteer(0));
        btnRight.addEventListener('pointerdown', () => handleSteer(1));
        btnRight.addEventListener('pointerup', () => handleSteer(0));

        btnBoost.addEventListener('pointerdown', () => handleBoost(true));
        btnBoost.addEventListener('pointerup', () => handleBoost(false));
        // Also add mouse/touch leave to prevent sticking
        btnBoost.addEventListener('pointerleave', () => handleBoost(false));
        btnLeft.addEventListener('pointerleave', () => handleSteer(0));
        btnRight.addEventListener('pointerleave', () => handleSteer(0));

        document.getElementById('btn-swap').addEventListener('click', () => {
            if (conn && conn.open) conn.send({ type: 'SWAP' });
            if (MY_ROLE === 'host') {
                const temp = state.driver;
                state.driver = state.speeder;
                state.speeder = temp;
                updateRoleUI();
            }
        });

        document.getElementById('btn-retry').addEventListener('click', () => {
            if (MY_ROLE === 'host') {
                conn.send({ type: 'RESTART' });
                startGame();
            }
        });

        function sendInput() {
            if (conn && conn.open) {
                conn.send({ type: 'INPUT', steer: state.inputSteer, boost: state.inputBoost });
            }
        }

        function startGame() {
            resetGame();
            // Start Logic Loop
            if (window.gameInterval) clearInterval(window.gameInterval);
            window.gameInterval = setInterval(gameLoop, 16);
        }

        function resetGame() {
            state.playing = true;
            state.score = 0;
            state.speed = 0;
            state.x = 0;
            state.obstacles = [];
            state.inputSteer = 0;
            state.inputBoost = false;

            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('score-val').innerText = "0";

            // Clear meshes
            obstacleGroup.clear();
            meshMap.clear();
        }

        function endGame(finalScore) {
            state.playing = false;
            clearInterval(window.gameInterval);
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('final-score').innerText = Math.floor(finalScore);
        }

        // HOST LOGIC LOOP
        function gameLoop() {
            if (!state.playing) return;

            // Speed
            const targetSpeed = state.inputBoost ? 1.5 : 0;
            state.speed += (targetSpeed - state.speed) * 0.1;
            state.score += state.speed;

            // Steer (Instant)
            state.x += state.inputSteer * 0.5;
            state.x = Math.max(-10, Math.min(10, state.x));

            // Spawn Obstacles
            if (Math.random() < 0.05 && state.speed > 0.1) {
                const z = -200;
                const x = (Math.random() - 0.5) * 20;
                const id = Math.random().toString(36);
                state.obstacles.push({ id, x, z });
            }

            // Move Obstacles & Collision
            for (let i = state.obstacles.length - 1; i >= 0; i--) {
                const o = state.obstacles[i];
                o.z += state.speed; // Move closer

                // Collision
                if (o.z > -2 && o.z < 2 && Math.abs(o.x - state.x) < 2.5) {
                    conn.send({ type: 'GAME_OVER', score: state.score });
                    endGame(state.score);
                    return;
                }

                if (o.z > 10) state.obstacles.splice(i, 1);
            }

            // Sync
            if (conn && conn.open) {
                conn.send({
                    type: 'STATE',
                    x: state.x,
                    speed: state.speed,
                    score: state.score,
                    obstacles: state.obstacles,
                    driver: state.driver,
                    speeder: state.speeder,
                    playing: state.playing
                });
            }
        }

        // RENDER LOOP
        function render() {
            requestAnimationFrame(render);

            // Player
            player.position.x = state.x;
            player.rotation.z = -state.inputSteer * 0.5;

            // Tunnel effect
            tunnel.rotation.y += state.speed * 0.01;

            // Obstacles Sync
            const currentIds = new Set(state.obstacles.map(o => o.id));

            // Remove old
            for (const [id, mesh] of meshMap) {
                if (!currentIds.has(id)) {
                    obstacleGroup.remove(mesh);
                    meshMap.delete(id);
                }
            }

            // Add/Update new
            state.obstacles.forEach(o => {
                let mesh = meshMap.get(o.id);
                if (!mesh) {
                    mesh = createObstacle(o.z, o.x, o.id);
                    obstacleGroup.add(mesh);
                    meshMap.set(o.id, mesh);
                }
                mesh.position.z = o.z;
                mesh.position.x = o.x;
            });

            document.getElementById('score-val').innerText = Math.floor(state.score);
            renderer.render(scene, camera);
        }
        render();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initNetwork();

    </script>
</body>
</html>
