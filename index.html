<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ORBIT: A Journey for Two</title>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* CSS Reset & Base */
        * { box-sizing: border-box; touch-action: none; }
        body {
            margin: 0; overflow: hidden; background: #000; color: #fff;
            font-family: 'Orbitron', sans-serif;
            -webkit-user-select: none; user-select: none;
        }

        /* Fullscreen Canvas */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* UI Layer (Overlay) */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas when game is active */
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        /* Screens (Login, Waiting, Game Over) */
        .screen {
            pointer-events: auto; /* Re-enable clicks for UI elements */
            background: rgba(10, 10, 20, 0.9);
            padding: 2rem;
            border: 2px solid #00ffff;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            text-align: center;
            width: 90%; max-width: 400px;
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        .hidden { opacity: 0; pointer-events: none; transform: scale(0.9); display: none; }

        h1 { margin: 0 0 10px; font-size: 2.5rem; text-shadow: 0 0 10px #f0f; color: #fff; letter-spacing: 2px; }
        p { color: #aaa; margin-bottom: 20px; font-size: 0.9rem; }

        .input-group { margin-bottom: 15px; text-align: left; }
        label { display: block; font-size: 0.8rem; color: #0ff; margin-bottom: 5px; }
        input {
            width: 100%; padding: 12px; background: #111; border: 1px solid #333;
            color: #fff; font-family: 'Orbitron', sans-serif; font-size: 1.1rem;
            text-align: center; border-radius: 5px; outline: none; transition: border 0.3s;
        }
        input:focus { border-color: #f0f; box-shadow: 0 0 10px rgba(255, 0, 255, 0.5); }

        button {
            width: 100%; padding: 15px; background: linear-gradient(45deg, #00ffff, #0088ff);
            border: none; color: #000; font-family: 'Orbitron', sans-serif; font-weight: bold;
            font-size: 1.2rem; cursor: pointer; border-radius: 5px; text-transform: uppercase;
            margin-top: 10px; transition: transform 0.2s, box-shadow 0.2s;
        }
        button:active { transform: scale(0.98); }
        button.secondary { background: transparent; border: 2px solid #555; color: #aaa; margin-top: 10px; }

        /* HUD (Heads Up Display) */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;
            display: none; /* Hidden until game starts */
        }
        .hud-top { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; }
        .score-box { font-size: 1.5rem; color: #f0f; text-shadow: 0 0 10px #f0f; }
        .status-box { font-size: 0.8rem; color: #0ff; text-transform: uppercase; }

        /* Mobile Controls */
        #controls-overlay {
            position: absolute; bottom: 40px; left: 0; width: 100%; text-align: center;
            pointer-events: none; z-index: 6; display: none;
        }
        .control-hint { font-size: 0.8rem; opacity: 0.6; margin-bottom: 10px; }
        .touch-pad {
            width: 120px; height: 120px; border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 50%; margin: 0 auto; position: relative; pointer-events: auto;
        }
        .stick {
            width: 40px; height: 40px; background: rgba(0, 255, 255, 0.5); border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            pointer-events: none; box-shadow: 0 0 15px #0ff;
        }

        /* Loading Spinner */
        .loader {
            border: 4px solid #333; border-top: 4px solid #f0f; border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #copy-btn { background: #333; color: #fff; font-size: 0.8rem; padding: 5px 10px; margin-top: 5px; width: auto; display: inline-block; }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer">

        <!-- Screen 1: Mode Selection -->
        <div id="start-screen" class="screen">
            <h1>ORBIT</h1>
            <p>A Synchronized Experience</p>
            <button id="btn-create">Create Room (Host)</button>
            <button id="btn-join-menu" class="secondary">Join Room</button>
            <p style="font-size: 0.7rem; margin-top: 20px; opacity: 0.5;">Powered by PeerJS & Cloudflare</p>
        </div>

        <!-- Screen 2: Join Input -->
        <div id="join-screen" class="screen hidden">
            <h1>Join</h1>
            <div class="input-group">
                <label>Room ID</label>
                <input type="text" id="room-input" placeholder="e.g. A1B2C3" maxlength="10">
            </div>
            <button id="btn-connect">Connect</button>
            <button id="btn-back" class="secondary">Back</button>
        </div>

        <!-- Screen 3: Lobby (Waiting for P2) -->
        <div id="lobby-screen" class="screen hidden">
            <h1>Waiting...</h1>
            <p>Share this Room ID with your Player 2:</p>
            <h2 id="display-room-code" style="font-size: 2rem; color: #0ff; margin: 10px 0; letter-spacing: 5px;">---</h2>
            <button id="copy-btn">Copy Link</button>
            <div class="loader"></div>
            <p id="lobby-status">Waiting for connection...</p>
        </div>

        <!-- Screen 3.5: Tutorial -->
        <div id="tutorial-screen" class="screen hidden">
            <h1>HOW TO PLAY</h1>
            <div style="text-align: left; margin: 20px 0;">
                <p>1. <strong>DRAG</strong> anywhere on screen to move.</p>
                <p>2. <strong>DODGE</strong> the red energy blocks.</p>
                <p>3. <strong>STAY CLOSE</strong> to your partner for Sync Bonus.</p>
            </div>
            <button id="btn-ready">READY</button>
            <p id="tutorial-status" style="font-size: 0.8rem; margin-top: 10px; opacity: 0; transition: opacity 0.3s;">Waiting for partner...</p>
        </div>

        <!-- Screen 4: Game Over -->
        <div id="game-over-screen" class="screen hidden">
            <h1 style="color: #ff0055;">CRASHED</h1>
            <p>Distance Traveled: <span id="final-score" style="color: #fff; font-weight: bold;">0</span> km</p>
            <button id="btn-restart">Retry</button>
            <button id="btn-disconnect" class="secondary" style="margin-top: 10px; border-color: #ff0055; color: #ff0055;">Disconnect</button>
            <p id="retry-status" style="font-size: 0.8rem; margin-top: 10px; opacity: 0; transition: opacity 0.3s;">Waiting for partner...</p>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-top">
            <div class="status-box" id="connection-status">CONNECTED</div>
            <div class="score-box">
                <div style="font-size: 0.8rem; color: #aaa;">DISTANCE</div>
                <span id="score">0</span> km
            </div>
            <div class="score-box" style="text-align: right;">
                <div style="font-size: 0.8rem; color: #ff0055;">SYNC</div>
                <span id="sync-meter">0</span>%
            </div>
        </div>
        <div id="controls-overlay">
            <div class="control-hint">DRAG TO MOVE</div>
            <div class="touch-pad" id="joystick-zone">
                <div class="stick" id="joystick-knob"></div>
            </div>
        </div>
    </div>

    <!-- Libraries -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Post Processing -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
     
        const WORKER_API_URL = "https://billowing-pond-d006.dtech2j.workers.dev/";

        // --- GAME STATE ---
        const state = {
            role: null, // 'host' or 'client'
            roomId: null,
            connected: false,
            playing: false,
            score: 0,
            speed: 0.5,
            myPos: { x: 0, y: 0 },
            partnerPos: { x: 0, y: 0 },
            obstacles: [],
            proximityBonus: 0,
            isReady: false,
            partnerReady: false
        };

        // --- PEERJS SETUP ---
        let peer;
        let conn;

        function initPeer(id = null) {
            // Using default public PeerJS server (free)
            peer = new Peer(id);

            peer.on('open', (myId) => {
                console.log('My Peer ID:', myId);
                state.roomId = myId;
                if (state.role === 'host') {
                    document.getElementById('display-room-code').innerText = myId;
                    // Update URL for easy sharing
                    const url = new URL(window.location.href);
                    url.searchParams.set('room', myId);
                    window.history.pushState({}, '', url);
                }
            });

            peer.on('connection', (connection) => {
                console.log('Incoming connection...');
                handleConnection(connection);
            });

            peer.on('error', (err) => {
                console.error(err);
                alert("Connection Error: " + err.type);
            });
        }

        function handleConnection(connection) {
            conn = connection;
            state.connected = true;
            document.getElementById('lobby-status').innerText = "Partner Found! Starting...";
            document.getElementById('connection-status').innerText = "LINKED";
            document.getElementById('connection-status').style.color = "#0f0";

            // Setup data handler
            conn.on('data', (data) => {
                handleData(data);
            });

            if (conn.open) {
                 showScreen('tutorial');
            } else {
                 conn.on('open', () => {
                     showScreen('tutorial');
                 });
            }

            conn.on('close', () => {
                state.connected = false;
                alert("Partner Disconnected!");
                endGame();
            });
        }

        function handleData(data) {
            if (data.type === 'POS') {
                // Update partner position visualization
                state.partnerPos.x = data.x;
                state.partnerPos.y = data.y;
            } else if (data.type === 'READY') {
                state.partnerReady = true;
                checkStartCondition();
            } else if (data.type === 'START') {
                startGame();
            } else if (data.type === 'GAME_OVER') {
                endGame(data.score);
            } else if (data.type === 'SYNC_WORLD' && state.role === 'client') {
                // Client receives obstacle data from Host to stay in sync
                state.obstacles = data.obstacles;
                state.score = data.score;
                state.proximityBonus = data.sync || 0;

                // Update Obstacle Meshes for Client
                obstacleGroup.children.forEach((obs, i) => {
                     if (state.obstacles[i]) {
                         obs.position.x = state.obstacles[i].x;
                         obs.position.y = state.obstacles[i].y;
                         obs.position.z = state.obstacles[i].z;
                     }
                });

                // Render score
                document.getElementById('score').innerText = Math.floor(state.score);
                document.getElementById('sync-meter').innerText = Math.floor(state.proximityBonus);
            }
        }

        // --- UI LOGIC ---
        const screens = {
            start: document.getElementById('start-screen'),
            join: document.getElementById('join-screen'),
            lobby: document.getElementById('lobby-screen'),
            tutorial: document.getElementById('tutorial-screen'),
            gameover: document.getElementById('game-over-screen')
        };

        function showScreen(name) {
            Object.values(screens).forEach(s => s.classList.add('hidden'));
            if (screens[name]) screens[name].classList.remove('hidden');
        }

        // Auto-join from URL
        const urlParams = new URLSearchParams(window.location.search);
        const roomFromUrl = urlParams.get('room');
        if (roomFromUrl) {
            showScreen('join');
            document.getElementById('room-input').value = roomFromUrl;
        }

        document.getElementById('btn-create').addEventListener('click', async () => {
            state.role = 'host';
            showScreen('lobby');
            document.getElementById('display-room-code').innerText = "GENERATING...";

            let roomId;
            try {
                // Try to fetch from Worker first
                if (WORKER_API_URL && WORKER_API_URL.includes("workers.dev")) {
                     const res = await fetch(WORKER_API_URL + "/api/create-room");
                     if (res.ok) {
                         const data = await res.json();
                         roomId = data.room;
                     }
                }
            } catch (e) {
                console.warn("Worker API failed, falling back to local ID", e);
            }

            // Fallback to local random ID if Worker fails or is not configured
            if (!roomId) {
                roomId = Math.random().toString(36).substring(2, 7).toUpperCase();
            }

            initPeer(roomId);
        });

        document.getElementById('btn-join-menu').addEventListener('click', () => {
            showScreen('join');
        });

        document.getElementById('btn-connect').addEventListener('click', () => {
            const roomId = document.getElementById('room-input').value.toUpperCase();
            if (!roomId) return;

            state.role = 'client';
            document.getElementById('btn-connect').innerText = "Connecting...";

            // Init my peer with no ID (let server assign one)
            peer = new Peer();
            peer.on('open', () => {
                // Connect to host
                conn = peer.connect(roomId);
                conn.on('open', () => {
                    console.log("Connected to Host");
                    handleConnection(conn);
                });
                conn.on('data', (data) => handleData(data));
            });
        });

        document.getElementById('copy-btn').addEventListener('click', () => {
            const url = window.location.href;
            navigator.clipboard.writeText(url).then(() => {
                document.getElementById('copy-btn').innerText = "Copied!";
                setTimeout(() => document.getElementById('copy-btn').innerText = "Copy Link", 2000);
            });
        });

        function handleReady() {
             state.isReady = true;

             // Update UI for waiting
             document.getElementById('btn-ready').innerText = "WAITING...";
             document.getElementById('btn-restart').innerText = "WAITING...";

             const msg = "Waiting for partner...";
             document.getElementById('tutorial-status').innerText = msg;
             document.getElementById('tutorial-status').style.opacity = '1';
             document.getElementById('retry-status').innerText = msg;
             document.getElementById('retry-status').style.opacity = '1';

             if (conn && conn.open) {
                 conn.send({ type: 'READY' });
             }
             checkStartCondition();
        }

        document.getElementById('btn-ready').addEventListener('click', handleReady);
        document.getElementById('btn-restart').addEventListener('click', handleReady);

        document.getElementById('btn-disconnect').addEventListener('click', () => {
            if(conn) conn.close();
            location.reload();
        });

        // --- THREE.JS VISUALS ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03); // Fog for depth

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        camera.position.y = 1;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Bloom Effect
        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 2.0;
        bloomPass.radius = 0.5;
        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // Tunnel Geometry (Infinite Cylinder)
        const tunnelGeo = new THREE.CylinderGeometry(10, 10, 100, 32, 20, true);
        const tunnelMat = new THREE.MeshBasicMaterial({
            color: 0x220033,
            wireframe: true,
            side: THREE.BackSide,
            transparent: true,
            opacity: 0.1
        });
        const tunnel = new THREE.Mesh(tunnelGeo, tunnelMat);
        tunnel.rotation.x = -Math.PI / 2;
        scene.add(tunnel);

        // Starfield Particles
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 1000;
        const posArray = new Float32Array(starsCount * 3);
        for(let i=0; i<starsCount*3; i++) {
            posArray[i] = (Math.random() - 0.5) * 50; // Spread wide
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starsMat = new THREE.PointsMaterial({ size: 0.1, color: 0xffffff });
        const starMesh = new THREE.Points(starsGeo, starsMat);
        scene.add(starMesh);

        // Players
        const playerGeo = new THREE.TetrahedronGeometry(0.5);
        const playerMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
        const playerMesh = new THREE.Mesh(playerGeo, playerMat);
        scene.add(playerMesh);

        const partnerGeo = new THREE.TetrahedronGeometry(0.5);
        const partnerMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true });
        const partnerMesh = new THREE.Mesh(partnerGeo, partnerMat);
        scene.add(partnerMesh);

        // Obstacles Pool
        const obstacleGroup = new THREE.Group();
        scene.add(obstacleGroup);

        function resetGame() {
            state.playing = false;
            state.score = 0;
            state.speed = 0.5;
            state.proximityBonus = 0;
            state.obstacles = [];
            state.isReady = false;
            state.partnerReady = false;

            // Reset Positions
            state.myPos = { x: 0, y: 0 };
            state.partnerPos = { x: 0, y: 0 };

            // Clear Three.js objects
            while(obstacleGroup.children.length > 0){
                const obj = obstacleGroup.children[0];
                obstacleGroup.remove(obj);
            }

            // Update UI
            document.getElementById('score').innerText = "0";
            document.getElementById('sync-meter').innerText = "0";
            document.getElementById('final-score').innerText = "0";

            // Hide HUD during reset (optional, but cleaner)
            document.getElementById('hud').style.display = 'none';
        }

        function createObstacle(z) {
            const geo = new THREE.BoxGeometry(2, 2, 2);
            // Solid core with transparency
            const mat = new THREE.MeshBasicMaterial({
                color: 0xff0055,
                transparent: true,
                opacity: 0.6
            });
            const mesh = new THREE.Mesh(geo, mat);

            // Bright wireframe edges
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff }));
            mesh.add(line);

            mesh.position.z = z;
            mesh.position.x = (Math.random() - 0.5) * 10; // Random X
            mesh.position.y = (Math.random() - 0.5) * 6;  // Random Y
            return mesh;
        }

        // --- GAME LOOP ---
        function checkStartCondition() {
            const statusMsg = "Partner Ready! Waiting for you...";

            if (state.isReady && state.partnerReady) {
                 // Both players are ready.
                 // If I am Host, I initiate the start.
                 if (state.role === 'host') {
                     if (conn && conn.open) conn.send({ type: 'START' });
                     startGame();
                 }
                 // If Client, do nothing. Host will send START signal which triggers startGame() via handleData.
            } else if (state.partnerReady && !state.isReady) {
                // Partner is waiting for me
                document.getElementById('tutorial-status').innerText = statusMsg;
                document.getElementById('tutorial-status').style.opacity = '1';

                document.getElementById('retry-status').innerText = statusMsg;
                document.getElementById('retry-status').style.opacity = '1';
            }
        }

        function startGame() {
            resetGame(); // Ensure clean state
            state.playing = true;
            showScreen(null); // Hide UI
            document.getElementById('hud').style.display = 'block';
            document.getElementById('controls-overlay').style.display = 'block';

            // Tell the other player to start
            if (state.role === 'host' && conn && conn.open) {
                conn.send({ type: 'START' });
            }

            // Create initial pool of obstacles for both Host and Client
            // The Host controls them, the Client updates them based on sync
            for(let i=0; i<10; i++) {
                const obs = createObstacle(-20 - (i * 20));
                obstacleGroup.add(obs);

                if (state.role === 'host') {
                    state.obstacles.push({
                        uuid: obs.uuid,
                        x: obs.position.x,
                        y: obs.position.y,
                        z: obs.position.z
                    });
                }
            }

            if (state.role === 'host') {
                syncWorld();
            }
        }

        function endGame(finalScore) {
            state.playing = false;
            document.getElementById('hud').style.display = 'none';
            document.getElementById('final-score').innerText = Math.floor(finalScore || state.score);

            // Reset Retry Button
            document.getElementById('btn-restart').innerText = "Retry";
            document.getElementById('retry-status').style.opacity = '0';

            showScreen('gameover');
        }

        function syncWorld() {
            if (conn && conn.open) {
                conn.send({
                    type: 'SYNC_WORLD',
                    obstacles: state.obstacles,
                    score: state.score,
                    sync: state.proximityBonus
                });
            }
        }

        // --- INPUT HANDLING ---
        const joystick = { x: 0, y: 0, active: false };
        const joyZone = document.getElementById('joystick-zone');
        const joyKnob = document.getElementById('joystick-knob');
        let startTouch = { x: 0, y: 0 };

        joyZone.addEventListener('pointerdown', (e) => {
            joystick.active = true;
            startTouch.x = e.clientX;
            startTouch.y = e.clientY;
            joyKnob.style.transition = 'none';
        });

        window.addEventListener('pointermove', (e) => {
            if (!joystick.active) return;
            const dx = e.clientX - startTouch.x;
            const dy = e.clientY - startTouch.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const maxDist = 40;

            const clampedDist = Math.min(dist, maxDist);
            const angle = Math.atan2(dy, dx);

            const knobX = Math.cos(angle) * clampedDist;
            const knobY = Math.sin(angle) * clampedDist;

            joyKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

            // Normalized input -1 to 1
            joystick.x = knobX / maxDist;
            joystick.y = -knobY / maxDist; // Invert Y for "Up is Up"
        });

        window.addEventListener('pointerup', () => {
            joystick.active = false;
            joystick.x = 0;
            joystick.y = 0;
            joyKnob.style.transform = `translate(-50%, -50%)`;
            joyKnob.style.transition = 'transform 0.2s';
        });

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            if (state.playing) {
                // Move Player
                state.myPos.x += joystick.x * 0.2;
                state.myPos.y += joystick.y * 0.2;

                // Clamp bounds
                state.myPos.x = Math.max(-5, Math.min(5, state.myPos.x));
                state.myPos.y = Math.max(-3, Math.min(3, state.myPos.y));

                // Update Mesh
                playerMesh.position.x = state.myPos.x;
                playerMesh.position.y = state.myPos.y;

                // Update Partner Mesh
                partnerMesh.position.x = state.partnerPos.x;
                partnerMesh.position.y = state.partnerPos.y;

                // Move Tunnel/Stars (Illusion of speed)
                tunnel.rotation.y += 0.005;
                starMesh.rotation.z += 0.002;

                // Host Logic: Move Obstacles & Collision
                if (state.role === 'host') {
                    state.score += 0.1;
                    document.getElementById('score').innerText = Math.floor(state.score);

                    // Calculate Proximity (Sync Meter)
                    const dx = state.myPos.x - state.partnerPos.x;
                    const dy = state.myPos.y - state.partnerPos.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < 2.0) {
                        state.proximityBonus = Math.min(100, state.proximityBonus + 0.5);
                    } else {
                        state.proximityBonus = Math.max(0, state.proximityBonus - 0.2);
                    }
                    document.getElementById('sync-meter').innerText = Math.floor(state.proximityBonus);

                    obstacleGroup.children.forEach(obs => {
                        obs.position.z += state.speed;

                        // Collision Check (Simple box) - Check BOTH players
                        const p1Hit = Math.abs(obs.position.z - playerMesh.position.z) < 1 &&
                                      Math.abs(obs.position.x - playerMesh.position.x) < 1.5 &&
                                      Math.abs(obs.position.y - playerMesh.position.y) < 1.5;

                        const p2Hit = Math.abs(obs.position.z - playerMesh.position.z) < 1 &&
                                      Math.abs(obs.position.x - state.partnerPos.x) < 1.5 &&
                                      Math.abs(obs.position.y - state.partnerPos.y) < 1.5;

                        if (p1Hit || p2Hit) {
                            // Hit!
                            conn.send({ type: 'GAME_OVER', score: state.score });
                            endGame(state.score);
                        }

                        // Reset if passed
                        if (obs.position.z > 5) {
                            obs.position.z = -100; // Recycle
                            obs.position.x = (Math.random() - 0.5) * 10;
                            obs.position.y = (Math.random() - 0.5) * 6;

                            // Update state model
                            const obsData = state.obstacles.find(o => o.uuid === obs.uuid);
                            if (obsData) {
                                obsData.z = obs.position.z;
                                obsData.x = obs.position.x;
                                obsData.y = obs.position.y;
                            }
                        } else {
                            // Update Z in state model
                             const obsData = state.obstacles.find(o => o.uuid === obs.uuid);
                            if (obsData) obsData.z = obs.position.z;
                        }
                    });

                    // Send Sync
                    if (conn && conn.open) {
                        conn.send({ type: 'POS', x: state.myPos.x, y: state.myPos.y });
                        // Throttle world sync to save bandwidth? For now, every frame is fine for local P2P
                        syncWorld();
                    }

                } else {
                    // Client Logic: Interpolate Obstacles
                    // Send my Pos
                    if (conn && conn.open) {
                        conn.send({ type: 'POS', x: state.myPos.x, y: state.myPos.y });
                    }

                    // Render obstacles based on received state
                    // (Simplified: Just re-using local group logic for visual smoothness)
                    // In a robust game, we'd snap positions. Here we just rely on visual continuity.
                     obstacleGroup.children.forEach((obs, i) => {
                         if (state.obstacles[i]) {
                             obs.position.x = state.obstacles[i].x;
                             obs.position.y = state.obstacles[i].y;
                             obs.position.z = state.obstacles[i].z;
                         }
                     });

                     document.getElementById('score').innerText = Math.floor(state.score);
                }
            }

            // Visual Flair
            playerMesh.rotation.z -= 0.02;
            playerMesh.rotation.y += 0.02;
            partnerMesh.rotation.z += 0.02;
            partnerMesh.rotation.y -= 0.02;

            composer.render();
        }

        animate();

        // Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
